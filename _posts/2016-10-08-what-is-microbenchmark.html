---
layout: post
title: What is a microbenchmark?
date: '2016-10-08T13:58:00.000-07:00'
tags: 
modified_time: '2016-10-08T13:58:21.621-07:00'
blogger_id: tag:blogger.com,1999:blog-5657688967837431090.post-2284338905152277008
blogger_orig_url: http://www.codeblueprint.co.uk/2016/10/what-is-microbenchmark.html
---

<div>Most people have heard of computer benchmarks (<a href="http://www.phoronix-test-suite.com/">Phoronix</a> being a good example), but not everyone is familiar with microbenchmarks.<br /><br /></div><div>While benchmarks are designed to accurately simulate real life workloads, a microbenchmark is a program designed to test a small piece of a larger system; they are always artificial and are not intended to represent normal use.<br /><br /></div><h3>When would you use a microbenchmark?</h3><div><br /></div><div>Both types are used to compare things such as computer hardware, different software versions, etc, and there's no hard and fast rule for distinguishing between the two. But a guiding principle is that benchmarks test entire systems while microbenchmarks test a single component or feature of those systems.<br /><br /></div><div>Because they focus on a single part of a larger system, microbenchmarks are often used to analyse the performance of critical code. They give developers answers to questions like, "How will that locking scheme scale?", "Is memory bandwidth a bottleneck for this workload?" and "How long does the most frequent operation take to execute?". <br /><br /></div><div>A simple microbenchmark might measure Linux system call latency -- how long the write() system call takes to execute, for instance. For a hypothetical web stack, it could measure the time HTTP GET requests take to execute, from receiving the request on the server to sending a response to the client (note how this is done exclusively on the server, not the client, because otherwise you would also be measuring network latency, not just HTTP GET processing).<br /><br /></div><div>On the kernel performance team at SUSE, we use a bunch of microbenchmarks to check for performance regressions between releases as we're developing the latest one. Not only do we compare historical data between releases to track and fix regressions, we'll sometimes use that data to write patches to improve the performance of the Linux kernel.<br /><br /></div><div>Somewhat related to writing patches to improve microbenchmark scores is testing hypothesis, e.g. changing the values of OS configuration parameters to see whether scores improve. The runtime of microbenchmarks are also usually (though not always) shorter, which helps in quickly getting answers to questions.<br /><br /></div><div>If you're a developer, writing your own microbenchmark is a great way to really understand how your code performs, especially if the OS and software stack don't provide any other way to measure things outside of your code. This was partially the reason that I wrote the <a href="https://github.com/mfleming/adrestia.git">adrestia</a> microbechnmark suite to measure the Linux scheduler load balancer.<br /><br /></div><h3>When would you not use a microbenchmark?</h3><div><br /></div><div>Of course, like everything, they have their limitations, and the results they produce are not always useful. Because the way they exercise the system isn't based on a realistic workload, it can be difficult to justify changing the software or hardware configuration purely to improve microbenchmark results, which are by definition, artificial.<br /><br /></div><div>Likewise if you're using them to aid with debugging, you need to be careful not to make the wrong choice if the artificial and real world workload do not behave the same way under some conditions. You can end up solving the wrong problem.<br /><br /></div><div>You will quickly run into trouble if you take a shotgun approach to performance analysis by using every microbenchmark you can find to help diagnose your issue. They're best used after first identifying the important parts of your system. Pretty much any microbenchmark will find a bottleneck, you need to make sure it's a bottleneck you care about.<br /><br /></div><div>It's always a good idea to use popular ones, because the internet is filled with anecdotal evidence of badly designed microbenchmarks that do not test what the author intended. Make sure you only use standard ones, or ones that you've verified work correctly.<br /><br /></div><div>But either way, they allow you to zoom in on your system and quickly understand and make improvements. They should be a part of every developer's toolkit.</div>