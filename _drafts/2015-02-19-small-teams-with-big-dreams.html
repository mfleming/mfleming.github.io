---
layout: post
title: Small Teams with Big Dreams
date: '2015-02-19T14:15:00.000-08:00'
author: Matt Fleming
tags: 
modified_time: '2015-02-19T14:15:09.077-08:00'
blogger_id: tag:blogger.com,1999:blog-5657688967837431090.post-7881947385790076698
blogger_orig_url: http://www.codeblueprint.co.uk/2015/02/small-teams-with-big-dreams.html
---

I love working in small teams. You really get to know your fellow developers when you work closely with them on a tough technical challenge and there's a great sense of camaraderie as everyone "chips in" to collectively solve problems.<br /><br />But I've found that it is incredibly important to work smarter, not harder when your team is limited in size. In my current team, working on the <a href="https://01.org/linux-uefi-validation" target="_blank">Linux UEFI Validation&nbsp;project</a>, we're always looking for a "scaling factor"; how can we amplify the effectiveness of our work. If you've got a vast army of developers are your disposal, it's easy to hammer on a problem without paying too much attention to your performance. Sure, meeting your target quicker is good for a team of any size, but with a small team, there's a very real chance you'll never achieve your goal.<br /><br />On the LUV Project, we make heavy use of automation. Uploading new live images to https://01.org? That's automated. So are the builds. In fact, as maintainer for the Linux kernel EFI code, I rely on the automated build and test infrastructure we've put together at Intel to validate the patches I apply.<br /><br />We are constantly assessing what works and what doesn't, and we implement a "try it and see" policy. To make sure this doesn't descend into chaos you have to be very honest about your mistakes.