---
layout: post
title: EFI changes in Linux Kernel v4.5
date: '2016-01-23T13:12:00.001-08:00'
author: Matt Fleming
tags: 
modified_time: '2016-01-23T14:48:58.620-08:00'
blogger_id: tag:blogger.com,1999:blog-5657688967837431090.post-7535469144074490124
blogger_orig_url: http://www.codeblueprint.co.uk/2016/01/efi-changes-in-linux-kernel-v45.html
---

<p>Of all the changes to the EFI subsystem that are pending for the v4.5 release, by far the largest change is the use of separate page tables during the execution of EFI runtime services. The kernel has included some code to switch to page tables that included additional mappings for over two years, since Borislav Petkov <a href="https://git.kernel.org/cgit/linux/kernel/git/mfleming/efi.git/commit/?id=d2f7cbe7b26a74dbbbf8f325b2a6fd01bc34032c">added static runtime virtual mappings</a> for the benefit of kexec on x86_64.</p><h3>Why Does Kexec Need Static Virtual Mappings?</h3><p>The purpose of kexec is to boot a Linux kernel image from within Linux without doing a full reset of your computer. This dramatically reduces the boot time by skipping re-initialisation of BIOS which is completely unaware of the fact that a new instance of the kernel may now be running. It would be reasonable to assume that the second kernel is equally unaware of the state of the BIOS, but that isn't the case. Particularly for UEFI, the kernel cares very much about the state of the BIOS and what EFI runtime services are available when it is booting. </p><p>Because the kernel has to distinguish between whether it's booting straight from the BIOS (or via a boot loader) or from another kernel via kexec, there are many code paths in the EFI subsystem that are duplicated, with minor differences. The one we're concerned about in this post is the code that sets up the kernel environment for interacting with EFI runtime services, and that calls SetVirtualAddressMap(). </p><p>SetVirtualAddressMap() is the UEFI service responsible for informing the BIOS which memory regions are installed when the runtime services are invoked. It takes a memory map as its argument that is constructed by the kernel which tells the BIOS where its regions have been mapped by the kernel. </p><p>SetVirtualAddressMap() can only be invoked once per boot, so every subsequent kernel that is booted via kexec has to use the same memory map that was used on the initial boot. Hence, the need for static mappings. </p><h3>Paying Lip Service to Separate Page Tables</h3><p>These mappings are inserted into the "trampoline" page table in the name of cleanliness - to isolate these mappings from every other kernel page table. The trampoline page table also includes a 1:1 (identity) mapping of memory which turns out to be super useful for buggy BIOS implementations that continue accessing 1:1 addresses after SetVirtualAddressMap(). </p><h3>Catching writable and executable regions</h3><p>Since the release of Linux kernel v4.4 some people may have noticed the following warning in the kernel boot log when booting on UEFI machines, <div class="well"><pre><br />      ------------[ cut here ]------------<br />      WARNING: CPU: 7 PID: 1 at arch/x86/mm/dump_pagetables.c:225 note_page+0x5dc/0x780()<br />      x86/mm: Found insecure W+X mapping at address ffff88000005f000/0xffff88000005f000<br />      ...<br />      x86/mm: Checked W+X mappings: FAILED, 165660 W+X pages found.<br />      ...<br /></pre></div><p>The warning is intended to catch mappings in the kernel page tables that are susceptible to being used by attackers to store malicious code. By ridding the kernel of these kinds of mappings it reduces the attack surface and makes it more difficult to escalate privileges in the event that an attack finds a vulnerability. </p><p>The static EFI runtime mappings suffer from this problem, and so, during the v4.5 development cycle I set out to fix this. </p><h3>Finally Getting Separate Page Tables</h3><p>Discovering that the EFI regions were vulnerable to attacks the initial solution was obviously to stop mapping them as both writeable and executable. It turns out that this isn't possible because the kernel has no idea  </p>